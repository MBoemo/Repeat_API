#!/usr/bin/env python

#----------------------------------------------------------
# Written by Michael A. Boemo (mb915@cam.ac.uk)
# This software is licensed under MIT.  You should have
# received a copy of the license with this software.  If
# not, please Email the author.
#----------------------------------------------------------

import warnings
import StringIO
import sys
import re
import copy
from Bio import SeqIO
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt


def reverseComplement(seq):
	newSeq = ''
	for s in seq:
		if s == 'A':
			newSeq += 'T'
		elif s == 'T':
			newSeq += 'A'
		elif s == 'C':
			newSeq += 'G'
		elif s == 'G':
			newSeq += 'C'
		else:
			warnings.warn("Nucleotides must be A, T, G, or C.")
			sys.exit()
			
	return newSeq[::-1]


def writeBedHeader(f,genome,repeat,minLength):

	f.write('#bed file generated by Repeat_API\n')
	f.write('#contact Michael Boemo (mb915@cam.ac.uk) with any issues\n')
	f.write('#reference genome: '+ genome + '\n')
	f.write('#repeat motif: '+ repeat + '\n')
	f.write('#minimum repeat length: '+ str(minLength)+'\n')
	f.write('#contig\tstart\tend\trepeat length\tstrand\n')


def parseRepeats(filename,repeat,useRC,minLength):

	f = open(repeat+'.bed','w')
	writeBedHeader(f,filename,repeat,minLength)
	lengths = {}

	fasta_sequences = SeqIO.index(filename,'fasta')
	for contig in fasta_sequences:

		seq = str(fasta_sequences[contig].seq).upper()

		repeat = copy.deepcopy(repeat).upper()

		for match in re.finditer('('+repeat+')+',seq):

			if minLength is not None:
				if match.end(0)-match.start(0) >= minLength:
					f.write(str(contig) + '\t' + str(match.start(0)) + '\t' + str(match.end(0)) + '\t' + str(match.end(0)-match.start(0))+'\ttemplate\n')
			else:
				f.write(str(contig) + '\t' + str(match.start(0)) + '\t' + str(match.end(0)) + '\t' + str(match.end(0)-match.start(0))+'\ttemplate\n')

			key = match.end(0)-match.start(0)
			if key in lengths:
				lengths[key] += 1
			else:
				lengths[key] = 1



		if useRC and repeat != reverseComplement(repeat):

			rcRepeat = reverseComplement(repeat)
			for match in re.finditer('('+rcRepeat+')+',seq):

				if minLength is not None:
					if match.end(0)-match.start(0) >= minLength:
						f.write(str(contig) + '\t' + str(match.start(0)) + '\t' + str(match.end(0)) + '\t' + str(match.end(0)-match.start(0))+'\tcomplement\n')
				else:
					f.write(str(contig) + '\t' + str(match.start(0)) + '\t' + str(match.end(0)) + '\t' + str(match.end(0)-match.start(0))+'\tcomplement\n')

				key = match.end(0)-match.start(0)
				if key in lengths:
					lengths[key] += 1
				else:
					lengths[key] = 1
	f.close()
	freqPlot(repeat+'.pdf',repeat,lengths)


def freqPlot(outFilename,repeat,lengths):
	
	#reshape
	x = []
	heights = []
	for key in sorted(lengths.keys()):
		x.append(key)
		heights.append(lengths[key])

	plt.figure()
	plt.bar(x,heights,log=True)
	plt.xlabel('Repeat Length')
	plt.ylabel('Count')
	plt.title('Distribution of '+repeat+' Repeat Lengths')
	plt.savefig(outFilename)
	
